import json
import logging
from typing import List, Optional
from openai import OpenAI
import streamlit as st

from models import AdScriptInput, SceneBeat, BrollPrompt
from config import Config, TONE_GUIDANCE, FORMAT_GUIDANCE

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize config
config = Config.from_env()

class BrollAgent:
    """Main agent class for B-roll generation"""
    
    def __init__(self, openai_client: OpenAI):
        self.client = openai_client
    
    def _get_system_prompt(self, tone: str, format_type: str) -> str:
        """Generate system prompt with tone and format guidance"""
        base_prompt = """
You are a professional video editing assistant specializing in B-roll generation.

Given a video script, break it into a list of B-roll moments designed to visually support the tone, format, and emotion of the message.

For each moment, output:
- A timestamp (e.g., 00:00, 00:05, etc.)
- A vivid, descriptive scene (ambient, symbolic, illustrative, or emotional)
- The core emotion the visual supports
- A short excerpt from the script that the scene should follow (for placement)

Guidelines:
- Use visuals that match or deepen the emotional tone
- Avoid referencing direct speakers or narrators unless appropriate to the format
- You may use symbolic or metaphorical imagery when relevant
- Be creative but stay relevant to the script's meaning and tone
- Do not refer to specific character names or identities â€” describe people generically
- Focus on cinematic, high-quality visual descriptions
- Each scene should be feasible for AI video generation or stock footage

Respond only in raw JSON. Do not include markdown or explanation.

Example format:
[
  {
    "timestamp": "00:00",
    "scene_description": "Fog drifting through a forest at dawn",
    "emotion": "mysterious",
    "script_excerpt": "I didn't know what I was searching for..."
  }
]
"""
        
        tone_guide = TONE_GUIDANCE.get(tone, "")
        format_guide = FORMAT_GUIDANCE.get(format_type, "")
        
        if tone_guide:
            base_prompt += f"\n\nTone guidance: {tone_guide}"
        if format_guide:
            base_prompt += f"\nFormat guidance: {format_guide}"
            
        return base_prompt
    
    @st.cache_data(ttl=config.CACHE_TTL)
    def parse_script(_self, script: str, tone: str, format_type: str) -> Optional[List[dict]]:
        """Parse script into emotional scene beats (cached version)"""
        try:
            system_prompt = _self._get_system_prompt(tone, format_type)
            user_prompt = f"""
            Script: {script}
            Tone: {tone}
            Format: {format_type}
            """

            response = _self.client.chat.completions.create(
                model=config.OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                timeout=30
            )

            beats_data = json.loads(response.choices[0].message.content)
            
            # Validate the response structure
            validated_beats = []
            for beat_data in beats_data:
                try:
                    beat = SceneBeat(**beat_data)
                    validated_beats.append(beat.dict())
                except Exception as e:
                    logger.warning(f"Skipping invalid beat: {e}")
                    continue
                    
            return validated_beats
            
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse JSON response: {e}")
            st.error("Failed to parse the script. The AI response was not in the expected format. Please try again.")
            return None
        except Exception as e:
            logger.error(f"API call failed: {e}")
            st.error(f"Service temporarily unavailable: {str(e)}. Please try again.")
            return None
    
    def _assess_generation_feasibility(self, scene_description: str) -> tuple[bool, float]:
        """Assess whether a scene can be generated by AI video tools"""
        try:
            response = self.client.chat.completions.create(
                model=config.OPENAI_MODEL,
                messages=[
                    {
                        "role": "system", 
                        "content": """You're an AI video generation advisor. Given a scene description, judge whether a generative video AI like Runway, Pika, or Kling could realistically generate this scene effectively.

Consider:
- Visual complexity and feasibility
- Current AI video generation capabilities
- Specificity and clarity of the description
- Realistic physics and movements

Respond with ONLY a JSON object:
{"feasible": true/false, "confidence": 0.0-1.0}

Be strict but realistic about current AI capabilities."""
                    },
                    {"role": "user", "content": scene_description}
                ],
                timeout=15
            )
            
            result = json.loads(response.choices[0].message.content)
            return result.get("feasible", False), result.get("confidence", 0.0)
            
        except Exception as e:
            logger.warning(f"Failed to assess feasibility: {e}")
            return True, 0.5  # Default to feasible with medium confidence
    
    def generate_prompts(self, beats_data: List[dict], duration: int = None, aspect_ratio: str = None) -> List[BrollPrompt]:
        """Convert scene beats into video generation prompts"""
        if duration is None:
            duration = config.DEFAULT_DURATION
        if aspect_ratio is None:
            aspect_ratio = config.DEFAULT_ASPECT_RATIO
            
        prompts = []
        
        for beat_data in beats_data:
            try:
                beat = SceneBeat(**beat_data)
                
                # Assess generation feasibility
                is_feasible, confidence = self._assess_generation_feasibility(beat.scene_description)
                
                if is_feasible and confidence > 0.3:  # Only include if reasonably feasible
                    formatted_prompt = f"{beat.scene_description}, cinematic, {beat.emotion} mood, high quality"
                    search_instruction = f"Search stock or AI video libraries for: '{beat.scene_description}' with a {beat.emotion} emotional tone."
                    
                    prompt_obj = BrollPrompt(
                        prompt=formatted_prompt,
                        duration=duration,
                        aspect_ratio=aspect_ratio,
                        insert_after=beat.script_excerpt,
                        search_instruction=search_instruction,
                        confidence_score=confidence
                    )
                    prompts.append(prompt_obj)
                else:
                    logger.info(f"Skipping low-feasibility scene: {beat.scene_description}")
                    
            except Exception as e:
                logger.warning(f"Failed to process beat: {e}")
                continue
        
        return prompts

def create_agent(openai_client: OpenAI) -> BrollAgent:
    """Factory function to create a BrollAgent instance"""
    return BrollAgent(openai_client)
